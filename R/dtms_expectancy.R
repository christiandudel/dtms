#' Calculate state expectancy
#'
#' @description
#' This function calculates the expected time spent in the transient states
#' (state expectancy).
#'
#' @details
#' If the argument `start_distr` is specified, the average of the state
#' expectancies over all starting states is calculated. The names and length
#' of `start_distr` need to match the starting states generated by this
#' function.
#'
#' The partial expectancy for the time spent in the transient states can be
#' calculated using the arguments `start_time` and `end_time`.
#'
#' Two corrections to the results will be applied per default. Both corrections
#' are required as the underlying formulas do actually not provide the
#' expected time spent in a state, but the number of visits to a state. Time
#' and visits are only equal under certain conditions; in particular, only if
#' transitions between states happen mid-interval and the step length of the
#' time scale is equal to one. The first correction will remove a certain amount
#' of time spent in a certain state if its equal to the starting state. This is
#' controlled with the argument `correction` which is applied multiplicative.
#' For instance, its default value 0.5 means that the state expectancy in some
#' state X starting from state X is reduced by 0.5 time steps. The second
#' correction uses the entry `timestep` of `dtms`, or alternatively the
#' argument `timestep`, and multiplies results with its value.
#'
#' @param matrix Matrix with transition probabilities, as generated with `dtms_matrix`.
#' @param dtms DTMS object as generated with `dtms`.
#' @param risk Character (otpional), name of one transient state. If specified expectancies are only shown for this state but by values of the time scale.
#' @param start_distr Numeric (optional), distribution of starting states. If specified, average expectancy over all starting states will be calculated. Only applied if risk=NULL.
#' @param start_state Character (optional), name of starting states. If NULL (default) all transient states will be used.
#' @param start_time Numeric (optional), value of time scale for start. If NULL (default) first value of time scale will be used.
#' @param end_time Numeric (optional), last value of time scale to consider. If NULL (default) all values of time scale starting from start_time will be used.
#' @param correction Numeric (optional), correction for expectancy when starting state and state under consideration match, see details. Defaults to 0.5.
#' @param transient Character (optional), names of transient states.
#' @param timescale Numeric (optional), values of time scale.
#' @param timestep Numeric (optional), step length of time scale.
#' @param total Logical (optional), calculate total expectancy. Default is TRUE. Only applied if risk=NULL.
#' @param verbose Logical (optional), indicate whether correction and adjustment for timestep are applied. Default is FALSE.
#' @param fundamental Logical (optional), return fundamental matrix? Default is FALSE.
#' @param sep Character (optional), separator between short state name and value of time scale. Default is `_`.
#'
#' @return Returns a matrix with state expectancy for all transient states.
#' @export
#'
#' @examples
#' ## Define model: Absorbing and transient states, time scale
#' simple <- dtms(transient=c("A","B"),
#'                absorbing="X",
#'                timescale=0:20)
#' ## Reshape to transition format
#' estdata <- dtms_format(data=simpledata,
#'                        dtms=simple,
#'                        idvar="id",
#'                        timevar="time",
#'                        statevar="state")
#' ## Clean
#' estdata <- dtms_clean(data=estdata,
#'                       dtms=simple)
#' # Fit model
#' fit <- dtms_fit(data=estdata)
#' ## Predict probabilities
#' probs    <- dtms_transitions(dtms=simple,
#'                              model = fit)
#' ## Get transition matrix
#' Tp <- dtms_matrix(dtms=simple,
#'                   probs=probs)
#' ## Get starting distribution
#' S <- dtms_start(dtms=simple,
#'                 data=estdata)
#' ## State expectancies
#' dtms_expectancy(dtms=simple,
#'                 matrix=Tp,
#'                 start_distr=S)

dtms_expectancy <- function(matrix,
                            dtms=NULL,
                            risk=NULL,
                            start_distr=NULL,
                            start_time=NULL,
                            start_state=NULL,
                            end_time=NULL,
                            transient=NULL,
                            timescale=NULL,
                            timestep=NULL,
                            correction=0.5,
                            total=T,
                            sep="_",
                            fundamental=F,
                            verbose = F) {

  # Use dtms if provided
  if(!is.null(dtms)) {

    # Check
    dtms_proper(dtms)

    # Use values
    transient <- dtms$transient
    timescale <- dtms$timescale
    timestep <- dtms$timestep
  }

  # Starting state and time
  if(is.null(start_state)) start_state <- transient
  if(is.null(start_time)) start_time <- min(timescale)

  # Starting states, long names
  starting <- dtms_combine(start_state,start_time,sep=sep)

  # Number of starting and receiving states
  nstart <- length(starting)
  ntransient <- length(transient)

  # Remove absorbing states
  matrix <- dtms_absorbing(matrix)

  # All transient states
  allstates <- rownames(matrix)

  # Fundamental matrix
  nstates <- dim(matrix)[1]
  Nmat <- solve(diag(1,nstates)-matrix)

  # Correction
  if(is.numeric(correction)) {

    # Adjust
    diag(Nmat) <- diag(Nmat) - correction

    # Output
    if(verbose) cat("(Applying correction)","\n\n")
  }

  # Only return fundamental matrix?
  if(fundamental) {
    return(Nmat)
  }

  # Variant 1: Expectation of all transient states
  if(is.null(risk)) {

    # Matrix for results
    result <- matrix(data=NA,ncol=ntransient,nrow=nstart)
    rownames(result) <- paste0("start:",starting)
    colnames(result) <- transient

    for(i in 1:ntransient) {

      # Get states
      selector <- dtms_in(allstates,transient[i],sep)

      # Use end_time if specified
      if(!is.null(end_time)) {
        times <- dtms_gettime(allstates,sep)
        times <- times<=end_time
        times[!is.logical(times)] <- F
        selector <- selector & times
      }

      # Calculate results and place
      if(nstart>1) tmp <- rowSums(Nmat[starting,selector]) else tmp <- sum(Nmat[starting,selector])

      # Place
      result[,transient[i]] <- tmp
    }

  }

  # Variant 2: Expectation in one state by time scale
  if(!is.null(risk)) {

    # Check
    if(length(risk)!=1) stop("Only one state allowed for 'risk'")

    # Get time right
    first <- which(timescale==start_time)
    if(is.null(end_time)) last <- length(timescale) else
      last <- which(timescale==end_time)
    times <- timescale[first:last]
    ntimes <- length(times)

    # Get right columns from fundamental matrix
    selector1 <- dtms_in(allstates,risk,sep)
    selector2 <- dtms_gettime(allstates,sep)%in%times
    selector <- selector1 & selector2

    # Get result
    tmp <- rowSums(Nmat[,selector])

    # Matrix with results
    result <- matrix(data=tmp,ncol=ntimes,nrow=nstart,byrow=T)
    rownames(result) <- transient
    colnames(result) <- paste(times)

  }

  # Calculate average if starting distribution is provided
  if(!is.null(start_distr) & is.null(risk)) {

    # Check if matching
    if(length(start_distr)!=dim(result)[1]) stop("Starting distribution too long or short")

    # Match to starting/row ordering of result
    start_distr <- start_distr[match(names(start_distr),starting)]

    # Calculate
    AVERAGE <- colSums(result*start_distr)

    # Put into matrix for results
    result <- rbind(result,AVERAGE)
  }

  # Add row totals
  if(total & is.null(risk)) {
    TOTAL <- rowSums(result)
    result <- cbind(result,TOTAL)
  }

  # Adjust for time step
  if(timestep!=1) {
    result <- result*timestep
    if(verbose) cat("Adjusting for step length","\n\n")
  }

  # Return result
  return(result)

}
