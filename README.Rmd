---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# dtms - An R package for discrete-time multistate models

<!-- badges: start -->
[![R-CMD-check](https://github.com/christiandudel/dtms/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/christiandudel/dtms/actions/workflows/R-CMD-check.yaml)
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

## Authors

Christian Dudel, dudel@demogr.mpg.de 

## Disclaimer

This package is currently undergoing development and many functions are 
experimental. The package comes with no warranty. The content of this repository 
will change in the future, and functions and features might be removed or 
changed without warning.

## Acknowledgements

We thank Peng Li,  Alessandro Feraldi, Aapo Hiilamo, Daniel Schneider, 
Donata Stonkute, Marcus Ebeling, and Angelo Lorenti for helpful comments, 
suggestions, and code snippets. All errors remain our own.

## Citation

If you use this package in your work, please use the following citation (or
a variation):

Dudel, C. (`r format(Sys.time(), "%Y")`). dtms: discrete-time multistate models 
in R. R package version `r packageVersion("dtms")`, available at  https://github.com/christiandudel/dtms/

## Overview

The package `dtms` implements discrete-time multistate models in R. It comes 
with many tools to analyze the results of multistate models. The workflow mainly 
consists of estimating a discrete-time multistate model and then applying 
methods for absorbing Markov chains.  

Currently, the following features are implemented:

- Data handling: functions for reshaping and aggregating data, cleaning data, 
editing states, generating indicators of duration and number of occurrences of 
a state, indicators of censoring, descriptive information on different types of 
censoring, and other general descriptive statistics. 
- Estimation of transition probabilities: nonparametric estimation;
semiparametric estimation ([VGAM](https://CRAN.R-project.org/package=VGAM)), 
random effects and random intercepts 
([mclogit](https://CRAN.R-project.org/package=mclogit)), 
and neural networks ([nnet](https://CRAN.R-project.org/package=nnet)); all
possible for constrained and unconstrained/fully interacted models. Functions 
for descriptive statistics on transition probabilities and for plotting them
are also available.
- Markov chain methods: survivorship function, (partial) state/life expectancy, 
(partial) lifetime risk, (partial) distribution of occupation time, (partial) 
distribution of waiting time to first visit, (partial) distribution of waiting 
time to last exit, (partial) distribution of waiting time to absorption, 
based on (partial) distributions variance/standard deviation and median of 
occupancy time/first visit/last exit/time to absorption, Markov chains with
rewards.
- Inference: analytic standard errors and variance-covariance matrix for 
transition probabilities; for all quantities inference using the resampling
bootstrap, the block bootstrap, and a parametric bootstrap, supporting parallel 
computing.
- Other features: simulation of Markov chains using the package
[markovchain](https://CRAN.R-project.org/package=markovchain); survey 
weights (experimental); irregular time intervals (experimental).
- Examples: the package comes with two simulated data sets which are used for
examples. These are described further below. The input data and code for the 
simulated data is available at https://github.com/christiandudel/dtms_data/.

The documentation provided below does currently not describe all features of the
package.

## Content 

Currently, the following topics are covered in this documentation

- Installation
- General workflow and basic principles
    + Model setup 
    + Preparing and handling data
    + Estimating transition probabilities
    + Markov chain methods
- Example 1: artificial data
    + Data description
    + Model setup 
    + Preparing and handling data
    + Estimating transition probabilities
    + Markov chain methods
- Example 2: simulated working trajectories
    + Data description
    + Analysis
    + Variance estimation
- Irregular intervals 
- Splines, random effects, and random slopes
- Combining dtms with other software
- Using dtms with secure data environments
- Using dtms with large data sets
- References

## Installation 

You can install the development version of `dtms` from GitHub like this:
``` r
install.packages("remotes")
remotes::install_github("christiandudel/dtms")
```

## General workflow and basic principles

The basic workflow consists of four main steps. First, the multistate model is
defined in a general way which describes the states included in the model and
its timescale (model setup). Second, the input data has to be reshaped and 
cleaned. Third, transition probabilities are estimated, either via 
multinomial logistic regression or with nonparametric methods. Fourth, Markov chain 
methods are applied to calculate statistics to describe the model. These steps 
and the corresponding functions are described below. Note that not all arguments 
of each function are described, and in many cases the help 
files for the individual functions contain useful additional information.

### Model setup

To use the `dtms` package, in a first step discrete-time multistate models 
are defined in a abstract way using three components: the names of the 
transient states; the names of the absorbing states; and the values of the 
time scale. Moreover, there are two additional components which the user not 
necessarily needs to specify: the step length of the timescale, and a separator. 

To define these components, the function `dtms()` is used. It has an 
argument for each of the components, but only three are necessary: the 
names of the transient states, the names of the absorbing states, and the
values of the time scale. The step length of the timescale is implicitly defined
by the values of the timescale, and the separator uses a default value which 
users likely do not want to change in a majority of applications. In the first
example provided further below, the function `dtms()` is called like this:
``` r
## Load package
library(dtms)
## Define model: Absorbing and transient states, time scale
simple <- dtms(transient=c("A","B"),
               absorbing="X",
               timescale=0:19)
```
The arguments `transient` and `absorbing` take the names of the
transient and absorbing states, respectively, which are specified as character
vectors. In example above, there are two transient states called `A` and `B`, and 
one absorbing state called `X`. Each model needs at least one transient state 
and one absorbing state. The argument `timescale` takes the values of the 
timescale which are specified with a numeric vector. In this example, the time 
scale starts at 0 and stops at 19, with a step length of 1. The step length does 
not need to equal 1; e.g., 0, 2, 4, 6, ... would be fine. Moreover, using 
the argument `timestep`, several values for the step length can be specified.

The separator is a character string used to construct what we call 
long state names. Its default is `_`. Long state names consist of a 
combination of the names of the transient states with values of
the time scale. They are used internally to handle that transition probabilities
might depend on values of the time scale. Long state names are never 
constructed for absorbing states. For instance, if the transient states are 
called `A` and `B`, the time scale can take on values 0, 1, and 2, and the
separator is `_`, then the following long state names will be used: `A_0`, 
`A_1`, `A_2`, `B_0`, `B_1`, and `B_2`. Due to the temporal ordering of states
not all transitions between these states are possible; e.g., it is not 
possible to transition from `A_2` to `B_0`. 

### Preparing and handling data

The input data has to be panel data in long format. If your data is not in this
shape, there are many tools already available in R which
allow you to reshape it. An example of data in long format could look like this:

```{r echo = FALSE, results='asis'}
dat <- data.frame(idvar=c(1,1,1,1,2,2,"..."),
                  timevar=c(0,1,2,3,0,1,"..."),
                  statevar=c("A","A","B","A","B","A","..."),
                  X=c(2,2,2,2,1,1,"..."),
                  Y=c(1020,1025,1015,1000,2300,2321,"..."))
library(knitr)
kable(dat)
```

The first variable, `idvar`, contains a unit identifier. The first four
rows of the data belong to unit `1`. The variable `timevar` has the 
values of the timescale. `statevar` shows the state each unit is 
occupying at a given time. Ideally, the states are provided as character 
strings; numeric values will also work. Factors are, however, currently not 
supported. `X` and `Z` are additional covariates. 

The `dtms` package provides tools to reshape this data into what we call
transition format. For the example data shown above the transition format looks 
like this:

```{r echo = FALSE, results='asis'}
dat <- data.frame(idvar=c(1,1,1,2,"..."),
                  timevar=c(0,1,2,0,"..."),
                  fromvar=c("A","A","B","B","..."),
                  tovar=c("A","B","A","A","..."),
                  X=c(2,2,2,1,"..."),
                  Y=c(1020,1025,1015,2300,"..."))
library(knitr)
kable(dat)
```

Each row shows for each unit (`idvar`) and given time (`timevar`) the
state currently occupied (`fromvar`) and the state the unit will transition
to at the next value of the time scale (`tovar`). For unit 1, the last
observation in long format is at time 3. However, this is the final observation
and there is no transition to another state after this. This means that the last
observed transition for unit 1 starts at time 2. 

To reshape data into transition format, the function `dtms_format()` can be
used. It is one of the many functions of the package which takes the result of
the function `dtms()` as one of its inputs. In the second example provided below
`dtms_format()` is used like this:
```{r data example}
## Load package
library(dtms)
## Define model: Absorbing and transient states, time scale
work <- dtms(transient=c("Working","Non-working","Retired"),
             absorbing="Dead",
             timescale=50:99)
## Reshape
estdata <- dtms_format(data=workdata,
                       dtms=work,
                       idvar="ID",
                       timevar="Age",
                       statevar="State")
```
First, `dtms()`is called to define the model. The call of `dtms_format()` specifies
the data frame which contains the data in long format (argument `data`), the
definition of the multistate model (argument `dtms`), the name of the variable
containing the unit identifier (argument `idvar`), the name of the variable
containing the values of the timescale (argument `timevar`), and the variable
indicating the states (argument `statevar`). 

Note that at this stage, the states captured by the variable specified with
`statevar` do not necessarily need to match the states in the `dtms` object. In
particular, this means that if there are any states in the input data which are
not in the `dtms` object, there will be no warning or similar at this stage.
However, the function `dtms_clean()` described below will remove states not
included in the `dtms` object by default.

The original data and the reshaped data can be compared like this:
```{r head}
workdata |> subset(ID==3) |> head()
estdata |> subset(id==3) |> head()
```
Three things are important to note. First, if not specified otherwise, 
`dtms_format()` changes variable names to default names. These default names are
also default values for other functions, meaning that certain variable names
do not need to be specified all the time, making the workflow easier. 
Specifically, the variable with the unit identifier gets the name `id`; the
variable with the timescale gets the name `time`; and the variables with the
starting and receiving state get the names `from` and `to`. Other names can be 
specified, but they have to be used consistently. 

Second, the object returned by `dtms_format()` is a standard data 
frame. This comes with benefits and costs. On the upside this means that data in 
transition format can easily be viewed and modified using standard tools, making
it very accessible to users. The main downside is that it does not contain
general information on the model or the data, which could make the workflow
more convenient. We decided to keep intermediate steps as accessible
as possible.

Third, the data in long format contains an additional variable (`Gender`). All
variables which are not `idvar`, `timevar`, or `statevar` do not need to be
specified and are handled in the same way. For any variables X, Y, Z, ... the
value at time $t$ is assigned to the transition starting in time $t$. 

A function for handling data in transition format is `dtms_clean()`. It
can be used to remove, for instance, transitions starting and/or ending in a
missing value. Depending on the data, these can occur quite frequently. For
instance, in the example used above:
```{r NA}
estdata |> subset(id==1) |> head()
```
This means that for the unit with ID 1, at least the first couple of transitions
only contain missing values. This is because in the original data these 
values are missing:
```{r NAhrs}
workdata |> subset(ID==1) |> head()
```
Technically, this is because `dtms_format()` takes each row in the input data and 
adds the state at the next value of the time scale to that row. If this next 
value is NA, or if it is not included in the data, the resulting value of `to' 
will be NA. 

Such missing values and a few other things can be removed as follows:
```{r clean}
estdata <- dtms_clean(data=estdata,
                      dtms=work)
```
`dtms_clean()` by default removes transitions starting or ending in a missing
value; transitions starting in an absorbing state; transitions which start
at a time not covered by the time scale; and transitions which start or end in
a state which is not contained in the state space in the `dtms` object. This
can be changed through some of the arguments of `dtms_clean()`.

### Estimating transition probabilities

Getting transition probabilities ready requires three steps. First, estimating a
regression model for the transition probabilities. Second, predicting 
transition probabilities using this model. Third, putting the transition 
probabilities into a transition matrix. In case of nonparametric estimation, the
first and second step are combined. 

Estimating a regression model is done using `dtms_fit()`. Currently, this 
function builds on several other packages to allow for, among other things, 
semiparametric estimation and random effects. In the first example below, we
show a very basic call of this function:
```r
## Fit model 
fit <- dtms_fit(data=estdata)
```
This will estimate a model which only uses the starting state as a control. 
Covariates (including time) can be included in several ways. A convenient way for 
including covariates is to use the argument `controls`. For example, if in a 
data set there are two variables named `Z1` and `Z2`, and time is captured with 
a variable called `time`, then these variables could be included as follows:
```r
fit <- dtms_fit(data=somedata,
                controls=c("time","Z1","Z2"))
```
It is also possible to specify a formula, like is common practice for most 
regression functions in R. This way you have to specify the names of
the state variables:
```r
fit <- dtms_fit(data=somedata,
                formula=to~from+time+Z1+Z2)
```

What class of object is generated by `dtms_fit()` depends on the package which
is used for estimation. This is controlled by the argument `package`, with
`VGAM` as default and then using the function `vgam()`. This means that the 
resulting objects of the short examples above have class `vgam` and behave 
accordingly, in particular with methods for functions like `summary()` or 
`coef()`. In addition to `VGAM`, currently `mclogit` and `nnet` are supported.
If the package is set to `mclogit` the function `mblogit()` is used. If it is
`nnet` the function is `multinom()`. Arguments of these functions can be passed
via `dtms_fit()`. For instance, this example includes random effects by unit ID 
using the `mclogit` package and the argument `random` of `mblogit()`:
```r
fit <- dtms_fit(data=somedata,
                covariates=c("time","Z1","Z2"),
                package="mclogit",
                random=~1|id)
```

Once a regression model has been estimated, it can be used to predict
transition probabilities. If the model includes covariates, the user needs to
specify covariate values which are used in the prediction. If no covariates are 
included, then no values are needed. For each time-constant covariate one value needs 
to be specified, and for time-varying variables a value at each value of the 
timescale has to be provided minus the last value. For instance, if the timescale 
has values 0, 1, 2, and 3, and there is a time-varying covariate X, then values 
for X at 0, 1, and 2 need to be specified. Alternatively, predictor values 
for all values of the time scale can be specified. In this case, the last 
predictor value will be dropped. For a time-constant covariate Y only one values 
is necessary, which is then used at all values of the time scale.

To predict transition probabilities, the function `dtms_transitions()` is used.
It has three main arguments: `model`, `dtms`, and `controls`. The
first argument is used to specify the object which contains the regression 
model. The argument `dtms` takes the definition of the multistate model as
generated by `dtms()`. The argument `controls` is only 
needed if there are covariates in the model. It take as lists with named 
entries, where the names need to correspond to the names of the covariates in 
the model. For instance, in a model with a timescale
with values 0, 1, 2, and 3, and a time-constant covariate Y and a time-varying
covariate X, the call of `dtms_transitions()` could look as follows:
```r
probs <- dtms_transitions(model=fit,
                          dtms=example,
                          controls=list(time=0:3,
                                        Y=1,
                                        X=c(500,501,500,503))) 
```

The result of calling `dtms_transitions()` is a data frame with predicted
transition probabilities, where each row contains the transition probability 
for one specific transition, as indicated by the variables in the data. This
object will often be only an intermediate step. However, the package provides
several tools to look at the transition probabilities (see the examples below), 
and putting the probabilities in a data frame makes them easily accessible to
the user.


### Markov chain methods

The dtms package provides several functions which implement Markov chain
methods and which can be applied to transition probabilities generated with
`dtms_transitions()`; moreover, they also work with transition matrices as
generated with `dtms_matrix()`. Most of these functions require at 
least two arguments. First, a data frame with transition probabilities or a 
transition matrix; and, second, a `dtms` object. For instance,
to calculate the lifetime spent in the different states, the function 
`dtms_expectancy()` is used. This and other functions are demonstrated in 
more detail in the two examples below.

## Example 1: Artificial data

### Data description

This is a basic example using artificial data which is provided with the 
package. The state space consists of two transient states (A, B), and one 
absorbing state (X). The time scale goes from 0 to 20. Transition probabilities 
do change depending on time, as we will see below. 

The following code loads the package and the data set. The data set is called 
'simpledata'.
```{r example1-data}
## Load package 
library(dtms)

## Look at data
head(simpledata)

## States
simpledata$state |> unique()

## Number of units
simpledata$id |> unique() |> length()

## Number of observations
dim(simpledata)
```
The data set is in long format and contains three variables. 'id' is an unit 
identifier; 'time' contains the value of the time scale; and 'state' contains 
the state the unit occupied at a given time. In total, there are 993 units, 
each of them contributing to the total of 12,173 observations. 

### Model setup

To work with this data set, we first define a basic discrete-time multistate 
model. This is done with the function `dtms()` and requires us to specify the
names of the transient states, the names of the absorbing states, and the 
possible values of the time scale: 
```{r example1-modeldef}
## Define model: Absorbing and transient states, time scale
simple <- dtms(transient=c("A","B"),
               absorbing="X",
               timescale=0:19)
```
The resulting object of class `dtms` will be passed to other functions of the 
package.

### Data handling

In a second step, we transform the data from long format to transition format. 
This can be done using the function `dtms_format()`. In this 
example, we need to specify the name of the object containing the data, and
in addition a `dtms` object as created above. Moreover, we need to specify which
variables contain the unit identifier, which variable contains the values of 
the time scale, and which variable contains the information on the state:
```{r example1-transformat}
## Reshape to transition format
estdata <- dtms_format(data=simpledata,
                       dtms=simple,
                       idvar="id",
                       timevar="time",
                       statevar="state")

## Look at reshaped data
head(estdata)
```
While in long format each row contains information on the currently occupied
state, in transition format also the next state is shown in a variable. If there
is no observation at time t+1, the next state is NA. The names of the variables 
in the resulting data set are by default chosen such that they match defaults of 
other functions of the package. 

Depending on the original data, there can be missing values in transition format
data due to several reasons. The function `dtms_clean()` provides a convenient
way to remove such rows in the data, as well as other potentially problematic
or unwanted rows. It returns a cleaned data set and prints a brief overview
of the dropped rows to the console:
```{r example1-cleaning}
## Missing values?
estdata$to |> table(useNA="always")

## Clean
estdata <- dtms_clean(data=estdata,
                      dtms=simple)
```
In this example, 1,260 transitions were dropped because they end in a missing
value. No observations were dropped because the states are not covered by the
state space; no observations are dropped because they are out of the time range 
specified with the 'dtms' object; and no observations were dropped because they
start in an absorbing state.

A brief overview of the data is provided when using the function `summary()`:
```{r example1-summary}
## Summary of data
summary(estdata)
```
This shows for all possible transitions the absolute number each transition is
observed (e.g., there are 160 transitions from A to X); the proportion of 
each transition relative to all transitions (e.g., a bit more than 1% of all
observed transitions are from A to X); and raw transition probabilities (e.g.,
the probability of transitioning to X starting in A is around 4%).

Some more information on the data is provided by the function `dtms_censoring()`.
It can be used in different ways, but a basic version shows an overview of
the number of units with left censoring, the number of units with gaps in their
series of observations, and the number of units with right censoring:
```{r example1-censoring}
dtms_censoring(data=estdata,
               dtms=simple)
```

### Estimating transition probabilities

To estimate the transition probabilities of the multistate model, the function 
`dtms_fit()` is used. In this simple example, it is sufficient to specify the 
name of the object with the transition data and the time scale as a control
variable:
```{r example1-fit}
## Fit model 
fit <- dtms_fit(data=estdata,
                controls="time")
```
To predict transition probabilities, the functions `dtms_transitions()` is used. 
It needs a 'dtms' object as well as a fitted model and values
for the control variable: 
```{r example1-probs}
## Predict probabilities
probs    <- dtms_transitions(dtms=simple,
                             model = fit,
                             controls=list(time=simple$timescale))
```
In more complex examples, the previous call would need more information. 
For instance, on which covariates to include in the estimation step, and which
covariate values to use in the prediction step. 

To get an overview of the transition probabilities, the function summary can be 
used:
```{r example1-probsctd}
## Summary of probabilities
summary(probs)
```
For all combinations of starting and receiving state, this shows the lowest 
transition probability and at what value of the time scale it occurs. It also
shows the same for the highest transition probability, and in addition it shows
the median and the mean of all transition probabilities between two states.

Another useful way to look at the transition probabilities is to plot them. To
make this easy, the package provides the function `dtms_simplify()` which can 
be applied to an object created with `dtms_transitions()` to make it easier to 
plot. For instance, using ggplot2, a simple plot could look like this:
```{r example1-probsplot}
## Simple plot
library(ggplot2)
probs |>  dtms_simplify() |> 
          ggplot(aes(x=time,y=P,color=to)) + 
          geom_line() + 
          facet_wrap(~from)
```
An even simpler way is available which builds on base-R and does not require 
ggplot2. However, this creates less nice figures and is mainly intended as a 
very quick way of checking results:
```{r example1-baseplot}
## Simple base plot
plot(probs,dtms=simple)
```

Nonparametric estimation of transition probabilities works slightly different
compared to the parametric case and can be done using the function 
`dtms_nonparametric()`:
```{r example1-nonpara}
nprobs <- dtms_nonparametric(data=estdata,
                             dtms=simple)
```
The resulting object directly contains transition probabilities, and the 
prediction step is not needed. Moreover, transition probabilities by default
depend on the values of the time scale. In case transition probabilities should 
depend on covariates, `dtms_nonparametric()` should be run with stratified 
subsets of the data. 

Before we generate more results, we calculate the starting distribution of
the states; i.e., the distribution of states at the first value of the time
scale. 
```{r example1-start}
## Get starting distribution 
S <- dtms_start(dtms=simple,
                data=estdata)
```
This step is not necessary, but its result can be passed to several of
the functions used for calculating Markov chain methods, providing additional 
information.

### Markov chain methods

Most functions used to calculate Markov chain methods need transition 
probabilities in a data frame (or a transition matrix) and a `dtms` object, 
and potentially further arguments. The two examples below 
calculate the expected time spent in a state (`dtms_expectancy()`) and the 
lifetime risk of ever reaching a state (`dtms_risk()`). In the first case, the 
starting distribution of states is passed to the function; this is optional. In 
the second case, one or several states need to be specified for which the 
lifetime risk will be calculated:
```{r example1-results1}
## State expectancies 
dtms_expectancy(dtms=simple,
                probs=probs,
                start_distr=S)

## Lifetime risk 
dtms_risk(dtms=simple,
          probs=probs,
          risk="A")
```
The results of the call of `dtms_expectancy()` show the starting states in rows
and the states in which the time is spent as columns. For instance, around 5.05
time units are spent in state A when starting in state A at time 0. The last 
column shows the total time until absorption. The last row is shown because the
starting distribution was specified. It shows the average time spent in a state
irrespective of the starting state. That is, on average 4.93 time units are 
spent in state A, and 8.88 time units are spent in state B, for a total of 13.81 
time units. 

The result of the call of `dtms_risk()` above is the lifetime risk of ever
reaching state A depending on the starting state. Obviously, when starting in 
state A at time 0, this risk amounts to 1. When starting in state B, the risk is
also very high and around 97%. Note that for consistent estimation the
Markov assumption has to hold. `dtms_risk()` can also be used such that the 
Markov assumption is not necessary, but this requires additional data editing
and use of the function `dtms_forward()`. In particular, the latter function
can be used to create an absorbing set which contains the state of interest
plus all absorbing states. This has to be done in the data editing 
process, and all following editing and estimation steps have to be repeated:
```{r example1-risk}
riskdata <- dtms_forward(data=estdata,
                         state="A",
                         dtms=simple)

riskfit <- dtms_fit(data=riskdata,
                controls="time",
                package="mclogit")

riskprobs <- dtms_transitions(dtms=simple,
                          controls=list(time=simple$timescale),
                          model = riskfit)

dtms_risk(dtms=simple,
          probs=riskprobs,
          risk="A")
```
In this example, the results of the naive use of `dtms_risk()` and the more 
elaborate approach using `dtms_forward()` lead to very similar results. 

It is also possible to calculate state expectancies conditional on values of
the time scale. For this, a single transient state has to be specified for 
which we want to know how long units spent in it:
```{r example1-results1var}
dtms_expectancy(dtms=simple,
                risk="A",
                probs=probs)
```
In the example above, we look at the time spent in state A. The results by row
now indicate the remaining life expectancy in state A starting from the state
in the row at a given time. For instance, if a unit is in state A at time 5,
an additional 3.51 time units will be spent in state A (as seen in row named 
"A", column named "5"). 

The function calls below are all similar in that they provide full distributions
as a result. Specifically, `dtms_visits()` calculates the distribution of the 
time spent in a state; the mean over this distribution is equal to the state 
expectancy as provided by `dtms_expectancy()`, and one minus the proportion of 
0 time units spent in a state is equal to the lifetime risk provided by 
`dtms_risk()`. `dtms_first()` calculates the distribution of the waiting time
until a given state is reached for the first time, conditional on ever reaching
this state. `dtms_last()` calculates the distribution of the waiting time until
a state is left for the last time; i.e., there is no return back to this state.
```{r example1-results2}
## Distribution of visits
dtms_visits(dtms=simple,
            probs=probs,
            risk="A",
            start_distr=S)

## Distribution of waiting time to first visit
dtms_first(dtms=simple,
           probs=probs,
           risk="A",
           start_distr=S)

## Distribution of waiting time to last exit
dtms_last(dtms=simple,
          probs=probs,
          risk="A",
          start_distr=S,
          rescale=TRUE,
          total=FALSE)
```
The output from these functions tends to be difficult to read, and often 
results on the distribution are used to calculate other statistics. A 
set of such statistics can be generated using the function `summary()`:
```{r example1-results2-ctd}
## Distribution of visits
example <- dtms_visits(dtms=simple,
                       probs=probs,
                       risk="A",
                       start_distr=S)
summary(example)
```
In the example above this returns, respectively, the average lifetime spent in
state A; the variance of the lifetime spent in state A; the standard deviation 
of the lifetime spent in state A; the median of the lifetime spent in state A;
 and the probability of spending zero lifetime in state A. Depending on which
 distribution this function is applied to, some entries might not be defined. 
 For instance: 
```{r example1-results2-ctd2}
## Distribution of waiting time to last exit
example2 <- dtms_last(dtms=simple,
                      probs=probs,
                      risk="A",
                      start_distr=S,
                      rescale=TRUE,
                      total=FALSE)
summary(example2)
```
In this case, the distribution is conditional on ever experiencing the exit
from state A, such that the waiting time until exit always has to be above 0. 

With respect to inference, the package currently provides analytic standard
errors for transition probabilities, and simulated inference for all other 
statistics. Standard errors for transition probabilities are provided by 
default by the function `dtms_transitions()`, and it can also return confidence
intervals. Two methods for simulated inference are implemented: the (simple) 
bootstrap and the block bootstrap. Both methods are provided by the function
`dtms_boot()`. How to use `dtms_transitions()` and `dtms_boot()` for inference
is demonstrated in the second example below.

## Example 2: Simulated working trajectories

### Data description

Here we provide an example using simulated working trajectories. The 
simulations are are conducted using transition 
probabilities estimated from the US Health and Retirement Study (HRS)
and published by Dudel & MyrskylÃ¤ (2017) 
who studied working trajectories in late working life and old age. These
transition probabilities are used to simulate artificial but realistic 
trajectories. There are three transient states 
(working, non-working, retired) and one absorbing state (dead). 
The time scale represents age and ranges from 50 to 99, as the focus is on older
individuals. Note that the actual HRS data is collected every two years and 
while the simulated data is annual. The data set also contains each individual's 
gender, and the transition probabilities underlying the simulated trajectories 
differ between men and women.

### Analysis

The workflow is similar to the previous example. First, a 'dtms' model is 
defined using the function `dtms'. Second, the data is brought into 
transition format and cleaned. Third, transition probabilities are estimated. 
In this example, probabilities are estimated
and predicted using time-constant and time-varying covariates, and the 
probabilities are plotted together with confidence intervals. Finally, the 
transition matrix is used to calculate state expectancies and similar measures. 

```{r example2}
## Load packages
library(dtms)
library(ggplot2)

## Define model: Absorbing and transient states, time scale
work <- dtms(transient=c("Working","Non-working","Retired"),
             absorbing="Dead",
             timescale=50:99)

## Quick look at data
head(workdata)

## Reshape
estdata <- dtms_format(data=workdata,
                       dtms=work,
                       idvar="ID",
                       timevar="Age",
                       statevar="State")

## Drop dead-to-dead transitions etc
estdata <- dtms_clean(data=estdata,
                      dtms=work)

## Overview
summary(estdata)

## Basic censoring
dtms_censoring(data=estdata,
               dtms=work)

## More advanced censoring example
estdata <- dtms_censoring(data=estdata,
                          dtms=work,
                          add=TRUE,
                          addtype="obs")

estdata |>
  subset(subset=to!="Dead",select=c(RIGHT,to)) |>
  table() |>
  prop.table(margin=1)

## Add age squared
estdata$time2 <- estdata$time^2
  
## Fit model
fit <- dtms_fit(data=estdata,
                controls=c("Gender","time","time2"))

## Transition probabilities by gender
  
# Men
probs_m <- dtms_transitions(dtms=work,
                            model = fit,
                            controls = list(Gender=0,
                                            time  =50:98,
                                            time2 =(50:98)^2),
                            ci=TRUE)
  
# Women
probs_w <- dtms_transitions(dtms=work,
                            model = fit,
                            controls = list(Gender=1,
                                            time  =50:98,
                                            time2 =(50:98)^2),
                            ci=TRUE)

# Overview
summary(probs_m)
summary(probs_w)

# Plotting, men as example
probs_m |>  dtms_simplify() |> 
            ggplot(aes(x=time,y=P,color=to)) + 
            geom_ribbon(aes(ymin = cilow, ymax = ciup,fill=to),alpha=0.5) +
            geom_line() + 
            facet_wrap(~from)
 
## Starting distributions
Sm <- dtms_start(dtms=work,
                 data=estdata,
                 variables=list(Gender=0))
  
Sw <- dtms_start(dtms=work,
                 data=estdata,
                 variables=list(Gender=1))
  
## State expectancies
dtms_expectancy(dtms=work,
                probs=probs_m,
                start_distr=Sm)
    
dtms_expectancy(dtms=work,
                probs=probs_w,
                start_distr=Sw)

## Variant: ignoring retirement as a starting state (shown only for men)
limited <- c("Working","Non-working")

Smwr <- dtms_start(dtms=work,
                   data=estdata,
                   start_state=limited,
                   variables=list(Gender=0))

dtms_expectancy(dtms=work,
                probs=probs_m,
                start_state=limited,
                start_distr=Smwr)

## Lifetime risk of reaching retirement
dtms_risk(dtms=work,
          probs=probs_m,
          risk="Retired",
          start_distr=Sm)
  
dtms_risk(dtms=work,
          probs=probs_w,
          risk="Retired",
          start_distr=Sw)
  
## Distribution of visits
visitsm <- dtms_visits(dtms=work,
                       probs=probs_m,
                       risk="Retired",
                       start_distr=Sm)
  
visitsw <- dtms_visits(dtms=work,
                       probs=probs_w,
                       risk="Retired",
                       start_distr=Sw,
                       method="end")

summary(visitsm)
summary(visitsw)
  
## First visit
firstm <- dtms_first(dtms=work,
                     probs=probs_m,
                     risk="Retired",
                     start_distr=Sm)  
  
firstw <- dtms_first(dtms=work,
                     probs=probs_w,
                     risk="Retired",
                     start_distr=Sw)  

summary(firstm)
summary(firstw)

## Last exit
  
# Leaving work to any state
last1m <- dtms_last(dtms=work,
                    probs=probs_m,
                    risk="Working",
                    start_distr=Sm)  
  
last1w <- dtms_last(dtms=work,
                    probs=probs_w,
                    risk="Working",
                    start_distr=Sw) 

summary(last1m)
summary(last1w)
  
# Leaving work for retirement
last2m <- dtms_last(dtms=work,
                    probs=probs_m,
                    risk="Working",
                    risk_to="Retired",
                    start_distr=Sm)  
  
last2w <- dtms_last(dtms=work,
                    probs=probs_w,
                    risk="Working",
                    risk_to="Retired",
                    start_distr=Sw)  

summary(last2m)
summary(last2w)
```

As already noted in the first example, consistent estimation of the lifetime
risk of reaching a state requires a different setup:
```{r example2lifetime}
riskdata <- dtms_forward(data=workdata,
                         state="Retired",
                         dtms=work,
                         idvar="ID",
                         timevar="Age",
                         statevar="State")

riskdata <- dtms_format(data=riskdata,
                       dtms=work,
                       idvar="ID",
                       timevar="Age",
                       statevar="State")

riskdata <- dtms_clean(data=riskdata,
                       dtms=work)

riskdata$time2 <- riskdata$time^2

riskfit <- dtms_fit(data=riskdata,
                controls=c("Gender","time","time2"),
                package="mclogit")

riskprobs <- dtms_transitions(dtms=work,
                            model = riskfit,
                            controls = list(Gender=0,
                                            time  =50:98,
                                            time2 =(50:98)^2),
                            ci=TRUE)


dtms_risk(dtms=work,
          probs=riskprobs,
          risk="Retired")
```

### Variance estimation

To use bootstrap methods, the function `dtms_boot()` is called, and results can
be conveniently viewed using `summary()`. The function `dtms_boot()` needs
data in transition format (argument `data`) and a `dtms` object. The argument 
`method` is used to choose the bootstrap method; here, we use the block 
bootstrap. In case the block bootstrap is used the argument `idvar` needs to be
specified, which takes the name of the variable with the unit identifier. The 
argument `rep` sets the number of bootstrap replications, and the argument
`parallel` can be set to `TRUE` to enable parallel processing using the
packages [foreach](https://CRAN.R-project.org/package=foreach) and 
[doParallel](https://CRAN.R-project.org/package=doParallel).

Further required is the argument `fun`. This is a function which should have two 
arguments, one called `data` and one called `dtms`. These are used to pass the
corresponding arguments from `dtms_boot()`. Other than this the function can 
contain anything the user is interested in. In the example above, the function
is called `bootfun`. It estimates transition probabilities, puts them into a
transition matrix, and then calculates state expectancies. Each bootstrap 
replication of the data is passed to the function specified by `fun`, and 
the results are saved in a list with as many entries as there are replications.
The format of each entry of the list obviously depends on the definition of 
`fun`. 

The result of calling `summary(bootresults)` is by default a list with two 
entries which together provide the bootstrap percentiles, i.e., the bootstrap
confidence interval. The entries have the structure defined by `fun`. In this
example, the upper half of each entry are the state expectancies for men, while
the lower half are the state expectancies for women. For instance, the 95%
confidence interval for the average lifetime spent working ranges from
12.17 years to 12.67 years for men. The returned percentiles can be controlled
with the arguments of the summary method, `dtms_boot_summary()`.
```{r example2boot}
# Bootstrap example 
bootfun <- function(data,dtms) {
 
   fit <- dtms_fit(data=data,
                   controls=c("Gender","time","time2"),
                   package="mclogit")
 
   probs_m <- dtms_transitions(dtms=dtms,
                               model = fit,
                               controls = list(Gender=0,
                                               time  =50:98,
                                               time2 =(50:98)^2))
 
   probs_w <- dtms_transitions(dtms=dtms,
                               model = fit,
                               controls = list(Gender=1,
                                               time  =50:98,
                                               time2 =(50:98)^2))
 
   Sm <- dtms_start(dtms=dtms,
                    data=data,
                    variables=list(Gender=0))
 
   Sw <- dtms_start(dtms=dtms,
                    data=data,
                    variables=list(Gender=1))
 
   res1 <- dtms_expectancy(dtms=dtms,
                   probs=probs_m,
                   start_distr=Sm)
 
   res2 <- dtms_expectancy(dtms=dtms,
                   probs=probs_w,
                   start_distr=Sw)
 
   rbind(res1,res2)
 
}
 
bootresults <- dtms_boot(data=estdata,
                         dtms=work,
                         fun=bootfun,
                         idvar="id",
                         rep=50,
                         method="block",
                         parallel=TRUE)

summary(bootresults)
```

## Using dtms with irregular intervals 

Longitudinal data is often not observed in regular intervals, but only 
irregular. For instance, respondents in a biannual longitudinal survey might 
not be interviewed exactly every two years, but sometimes only one and a half
years might have passed, or two and a half years, or something in between. This
applies, for instance, to the U.S. Health and Retirement Study (HRS). 

A complete application showing how to handle irregular intervals with `dtms` 
using HRS data can be found online: https://github.com/christiandudel/hrs_hwle/
The basic steps are as follows, using the HRS code as an example. 
First, the `dtms`object used for transforming the data using `dtms_format()` 
needs to include not one, but several values for
the steplength:
```r
hrsdtms <- dtms(transient=c("working","not-working"),
                absorbing="dead",
                timescale=seq(50,98,1),
                timestep=1:3)
```
Here, values 1, 2, and 3 are used. Using this object with `dtms_format()` will 
keep all transitions which have an interval of 1, 2, or 3 time units. If in 
another application observations are every half year with a maximum interval of
3 and a half years, the argument could be set to `seq(0.5,3.5,by=0.5)`. Moreover
the values of the timescale are set to increase by units of 1 from 50 to 98, as 
respondents in the HRS cover the population aged 50 and older, and age is 
measured in completed years; 98 is used as the highest age in which 
transitions can start. Already note that this `dtms` object will not be used
to predict transition probabilities. 

Second, using this `dtms`object with `dtms_format()` should use the argument 
`steplength=TRUE`, like: 
```r
estdata <- dtms_format(data=hrsdata,
                       dtms=hrsdtms,
                       steplength=TRUE)
```
In the resulting data set, there will be a variable called `steplength` which
for each transition indicates the interval. The name of this variable can be
controlled using the argument `stepvar`. 

Third, the interval should be included as a predictor when estimating the
transition probabilities: 
```r
fit <- dtms_fit(data=somedata,
                controls=c("time","steplength"))
```
The above example will include the interval width as a linear predictor. Whether
this is meaningful, or some other specification should be used, will depend on 
the specific application. 

Fourth, a new `dtms` object is created which is used for predicting transition
probabilities: 
```r
hrspredict <- dtms(transient=c("working","not-working"),
                     absorbing="dead",
                     timescale=seq(50,98,2))
```
In contrast to the previous `dtms` object, this uses only one fixed interval 
length. Which fixed value is used is a choice of the user, and will likely 
depend on the distribution of the intervals; if, for instance, most observations
are two years apart, and only a few one or three years, then using a fixed
interval of two years will be most supported by the data. This `dtms` object is 
next combined with `dtms_transitions`: 
```r
dtms_transitions(dtms=hrspredict,
                 model=fit,
                 controls=list(time=seq(50,98,2),
                               steplength=2))
```
This predicts transition probabilities transitioning from age 50 to age 52,
from age 52 to age 54, and so on up to transitioning from 98 to 100 and then 
dying; thus it also uses a fixed interval of 2, which is explicit not only
in the values of the time scale used for prediction, but also the value for
the variable `steplength`. The resulting transition probabilities can be used
like any other transition probabilities. 

## Splines, random effects, and random slopes

`dtms` builds on the packages `VGAM` and `mclogit` to allow semiparametric 
models with splines and models with random effects and random slopes. Splines
can be fitted using the function `s()` either within the argument `controls` 
or the argument `formula` of `dtms_fit()`:
```r
fit <- dtms_fit(data=estdata,
                controls=c("s(time)"),
                package="VGAM")
```
Random effects and slopes can be specified using the argument `random` which 
is passed to the underlying function from `mclogit`:
```r
fit <- dtms_fit(data=estdata,
                controls=c("time"),
                package="mclogit",
                random=~1|id)
```

## Combining dtms with other software

`dtms` can easily be used without doing the full workflow in `dtms` itself. For
instance, transition probabilities could be calculated with a different software
and `dtms` could then only used to calculate state expectancies or similar 
indicators. 

To do this, two things need to be kept in mind. The first is that objects from
the `dtms` package have a specific structure, and data or results from
other software need to have the correct structure. For instance, the function
`dtms_transitions()` outputs transition probabilities in a certain way. 
Users who want to import transition probabilities should arrange these
probabilities the same way.

Second, most objects generated by `dtms` have specific object 
classes. For instance, objects generated by `dtms_transitions()` and 
`dtms_nonparametric()` have two classes: `dtms_probs` and `data.frame`. 
User-generated objects need to have the right class(es) to work correctly with 
`dtms`.

## Using dtms with secure data environments

In many secure data environments, installing `dtms` will not be possible. There
are two major ways to still use `dtms`. The first is to export a tabulation 
of transitions and covariates from the secure environment, similar to what 
`dtms_aggregate()` does provide; i.e., for each transition, such as from some 
state A to some other state B, there is a count of transitions by the values of 
the time scale, and potentially further covariates. These counts can then be
used with the `weights` argument of functions such as `dtms_fit()`.

Sometimes it is possible to import existing code to a secure data environment.
In such a case, one of the two files in the folder `combined` in the GitHub 
repository https://github.com/christiandudel/dtms_combined/ can
be used. The file `all.R` is (almost) all code from `dtms`. Sourcing it should 
provide a lot of the functionality of the package; dependencies are still 
required, though. The file `selected.R` only includes a subset of the functions 
and removes most of the documentation, but is much smaller than `all.R`. Again
dependencies might be required.

## Using dtms with large data sets

With large data sets the execution time of the functions from this package
can be very high. A way to reduce the computational demands is by using
the function `dtms_aggregate()` and for inference the parametric bootstrap, as
described in the respective help pages. Depending on the data this can reduce 
the time needed for computations by 80% to 90%.

## References

Methodological papers:

- Schneider, D. C. (2023): Statistical inference for discrete-time multistate 
models: asymptotic covariance matrices, partial age ranges, and group contrasts.
MPIDR Working Paper WP-2023-041. https://dx.doi.org/10.4054/MPIDR-WP-2023-041 

- Dudel, C. (2021): Expanding the Markov chain tool box: distributions of 
occupation times and waiting times. Sociological Methods & Research 50: 401-428.
https://doi.org/10.1177/0049124118782541

- Dudel, C., MyrskylÃ¤, M. (2020): Estimating the number and length of episodes 
in disability using a Markov chain approach. Population Health Metrics 18: 15.
https://doi.org/10.1186/s12963-020-00217-0 

Papers using `dtms` for substantive questions:

- Hiilamo, A., Hermansen, A. (2026): Financial strain in Norway: The lifetime
risk of and expected time spent in payment problems. International Journal of
Social Welfare 35(1): e70053. https://doi.org/10.1111/ijsw.70053

- Abrams, L., Dudel, C., Feraldi, A. (2025): Who works while sick and who enjoys 
the golden years? Changing disparities in time spent in health and work after 
age 50 in the United States. Work, Aging and Retirement. 
https://doi.org/10.1093/workar/waaf023

- Moretti, M., Korhonen, K., van Raalte, A., Riffe, T., Martikainen, P. (2025):
Evolution of widowhood lifespan and its gender and educational inequalities in 
Finland over three decades. Demography 65(2): 1635-1660. 
https://doi.org/10.1215/00703370-12269717

- Feraldi, A., Sharma, S., Guidici, C. (2025): Gender gap in cancer-free life 
expectancy in the United States: the association with smoking, poor diet, and 
physical inactivity. Journal of Aging and Health. 
https://doi.org/10.1177/08982643251404299

- Hiilamo, A., PitkÃ¤nen, J., Moretti, M., Martikainen, P., MyrskylÃ¤, M. (2025): 
Children's out-of-home care in Finland, 1993â2020: lifetime risks, expectancies, 
exit routes, and number of placements for synthetic cohorts. Child Abuse & 
Neglect 169(1): 107626. https://doi.org/10.1016/j.chiabu.2025.107626



