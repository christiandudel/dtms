---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# dtms - An R package for discrete-time multistate models

<!-- badges: start -->
[![R-CMD-check](https://github.com/r-lib/usethis/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/r-lib/usethis/actions/workflows/R-CMD-check.yaml)
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

## Authors

Christian Dudel, dudel@demogr.mpg.de

Peng Li, li@demogr.mpg.de 

## Disclaimer

This package is currently undergoing development and many functions are 
experimental. The package comes with no warranty. The content of this repository 
will change in the future, and functions and features might be removed or 
changed without warning.

## Acknowledgements

We thank Alessandro Feraldi, Aapo Hiilamo, Daniel Schneider, and Angelo Lorenti
for helpful comments and suggestions.

## Overview

The package `dtms` implements discrete-time multistate models in R. It comes with 
many tools to analyze the results of multistate models. 
The workflow mainly consists of estimating a discrete-time multistate model and 
then applying methods for absorbing Markov chains. 

Currently, the following features are implemented:

- Data handling: functions for reshaping data, cleaning data, general descriptive
statistics, and descriptive information on different types of censoring. 
- Estimation of transition probabilities: builds on existing R packages, allowing 
for semiparametric estimation ([VGAM](https://cran.r-project.org/web/packages/VGAM)), 
random effects and random intercepts ([mclogit](https://cran.r-project.org/web/packages/mclogit)), 
and neural networks ([nnet](https://cran.r-project.org/web/packages/nnet)); all
possible for constrained and unconstrained/fully interacted models. Functions 
for descriptive statistics on transition probabilities and for plotting them
are also available.
- Markov chain methods: (partial) state/life expectancy, (partial) lifetime risk, 
(partial) distribution of occupation time, (partial) distribution of waiting 
time to first visit, (partial) distribution of waiting time to last exit, based 
on (partial) distributions variance/standard deviation and median of occupancy 
time and first visit/last exit, Markov chains with rewards.
- Inference: analytic standard errors and variance-covariance matrix for 
transition probabilities; simulated inference using the bootstrap and the block
bootstrap for other quantitites.
- Other features: simulation of Markov chains using the package
[markovchain](https://cran.r-project.org/web/packages/markovchain).
- Examples: the package comes with two simulated data sets which are used for
examples. These are described further below. The input data and code for the 
simulations is available at https://github.com/christiandudel/dtms_data/.

## Installation

You can install the development version of `dtms` like this:
``` r
library(devtools)
install_github("christiandudel/dtms")
```

## General workflow and basic principles

The basic workflow consists of four main steps. First, the multistate model is
defined in a general way which describes the states included in the model and
its timescale (model setup). Second, the input data has to be reshaped and cleaned. Third,
a regression model is fitted to predict transition probabilities. Fourth, 
Markov chain methods are applied to calculate statistics to describe the model.
These steps and the corresponding functions are described below. Note that
not all arguments of each function are described, and the help files for the
individual functions usually contain useful additional information.

### Model setup

To use the `dtms` package, in a first step disrete-time multistate models 
are defined in a abstract way using three components: the names of the 
transient states; the names of the absorbing states; and the values of the 
time scale. Moreover, there are two additional components which the user not 
necessarily needs to specify: the step length of the timescale, and a separator. 

To define these components, the function `dtms()` is used. It has an 
argument for each of the components, but only three are necessary: the 
names of the transient states, the names of the absorbing states, and the
values of the time scale. The step length of the timescale is implicitly defined
by the values of the timescale, and the separator uses a default value which 
users likely don't want to change in a majority of applications. In the first
example provided further below, the function `dtms()` is called like this:
``` r
## Load package
library(dtms)
## Define model: Absorbing and transient states, time scale
simple <- dtms(transient=c("A","B"),
               absorbing="X",
               timescale=0:19)
```
The arguments `transient` and `absorbing` take the names of the
transient and absorbing states, respectively, which are specified as character
vectors. In this case, there are two transient states called `A` and `B`, and 
one absorbing state called `X`. Each model needs at least one transient state 
and one absorbing state. The argument `timescale` takes the values of the 
timescale which are specified with a numeric vector. In this example, the time 
scale starts at 0 and stops at 19, with a step length of 1. The step length has 
to be consistent along the timescale. For instance, a timescale with values 
0, 1, 2, 4, 5, 7 is not allowed. However, the step length does not need to 
equal 1; e.g., 0, 2, 4, 6, ... would be fine. Moreover, using the argument 
`timestep`, several values for the step length can be specified.

The separator is a character string used to construct what we call 
long state names. Its default is `_`. Long state names consist of a 
combination of the names of the transient states with values of
the time scale. They are used internally to handle that transition probabilities
might depend on values of the time scale. Long state names are never 
constructed for absorbing states. For instance, if the transient states are 
called `A` and `B`, the time scale can take on values 0, 1, and 2, and the
separator is `_`, then the following long state names will be used: `A_0`, 
`A_1`, `A_2`, `B_0`, `B_1`, and `B_2`. Due to the temporal ordering of states
not all transitions between these states are possible; e.g., it is not 
possible to transition from `A_2` to `B_0`. 

### Preparing and handling data

The input data has to be panel data in long format. If your data is not in this
shape, there are many tools already available in R and its extensions which
allow you to reshape it. An example of data in long format could look like this:

```{r echo = FALSE, results='asis'}
dat <- data.frame(idvar=c(1,1,1,1,2,2,"..."),
                  timevar=c(0,1,2,3,0,1,"..."),
                  statevar=c("A","A","B","A","B","A","..."),
                  X=c(2,2,2,2,1,1,"..."),
                  Y=c(1020,1025,1015,1000,2300,2321,"..."))
library(knitr)
kable(dat)
```

The first variable, `idvar`, contains a unit identifier. The first four
rows of the data belong to unit `1`. The variable `timevar` has the 
values of the timescale. `statevar` shows the state each unit is 
occupying at a given time. Ideally, the states are provided as character 
strings; numeric values will also work, factors are, however, currently not 
supported. `X` and `Z` are additional covariates. 

The `dtms` package provides tools to reshape this data into what we call
transition format. For the example data shown above the transition format looks 
like this:

```{r echo = FALSE, results='asis'}
dat <- data.frame(idvar=c(1,1,1,2,"..."),
                  timevar=c(0,1,2,0,"..."),
                  fromvar=c("A","A","B","B","..."),
                  tovar=c("A","B","A","A","..."),
                  X=c(2,2,2,1,"..."),
                  Y=c(1020,1025,1015,2300,"..."))
library(knitr)
kable(dat)
```

Each row shows for each unit (`idvar`) and given time (`timevar`) the
state currently occupied (`fromvar`) and the state the unit will transition
to at the next value of the time scale (`tovar`). For unit 1, the last
observation in long format is at time 3. However, this is the final observation
and there is no transition to another state after this. This means that the last
observed transition for unit 1 starts at time 2. 

To reshape data into transition format, the function `dtms_format()` can be
used. It is one of the many functions of the package which takes the result of
the function `dtms()` as one of its inputs. In the second example provided below
`dtms_format()` is used like this:
```{r data example}
## Load package
library(dtms)
## Define model: Absorbing and transient states, time scale
hrs <- dtms(transient=c("Working","Non-working","Retired"),
            absorbing="Dead",
            timescale=50:99)
## Reshape
estdata <- dtms_format(data=hrsdata,
                       dtms=hrs,
                       idvar="ID",
                       timevar="Age",
                       statevar="State")
```
First, `dtms()`is called to define the model. The call of `dtms_format()` specifies
the data frame which contains the data in long format (argument `data`), the
definition of the multistate model (argument `dtms`), the name of the variable
containing the unit identifier (argument `idvar`), the name of the variable
containing the values of the timescale (argument `timevar`), and the variable
indicating the states (argument `statevar`). 

Note that at this stage, the states captured by the variable specified with
`statevar` do not necessarily need to match the states in the `dtms` object. In
particular, this means that if there are any states in the input data which are
not in the `dtms` object, there will be no warning or similar at this stage.
However, the function `dtms_clean()` described below will remove states not
included in the `dtms` object by default.

The original data and the reshaped data can be compared like this:
```{r head}
hrsdata |> subset(ID==3) |> head()
estdata |> subset(id==3) |> head()
```
Three things are important to note. First, if not specified otherwise, 
`dtms_format()` changes variable names to default names. These default names are
also default values for other functions, meaning that certain variable names
do not need to be specified all the time, making the workflow easier. 
Specifically, the variable with the unit identifier gets the name `id`; the
variable with the timescale gets the name `time`; and the variables with the
starting and receiving state get the names `from` and `to`. Other names can of
course be specified, but they have to be used consistently. 

Second, the object returned by `dtms_format()` technically is a standard data 
frame. This comes with benefits and costs. On the upside this means that data in 
transition format can easily be viewed and modified using standard tools, making
it very accessible to users. The main downside is that it does not contain
general information on the model or the data, which could make the workflow
slightly more convenient. We decided to keep intermediate steps as accessible
as possible.

Third, the data in long format contains an additional variable (`Gender`). All
variables which are not `idvar`, `timevar`, or `statevar` do not need to be
specified and are handled in the same way. For any variables X, Y, Z, ... the
value at time $t$ is assigned to the transition starting in time $t$. 

A useful function for handling data in transition format is `dtms_clean()`. It
can be used to remove, for instance, transitions starting and/or ending in a
missing value. Depending on the data, these can occur quite frequently. For
instance, in the example used above:
```{r NA}
estdata |> subset(id==1) |> head()
```
This means that for the unit with ID 1, at least the first couple of transitions
only contain missing values. This is because in the original data these 
values are missing:
```{r NAhrs}
hrsdata |> subset(ID==1) |> head()
```
Technically, this is because `dtms_format()` takes each row in the input data and 
adds the state at the next value of the time scale to that row. If this next 
value is NA, or if it is not included in the data, the resulting value of `to' 
will be NA. 

Such missing values and a few other things can be removed as follows:
```{r clean}
estdata <- dtms_clean(data=estdata,
                      dtms=hrs)
```
`dtms_clean()` by default removes transitions starting or ending in a missing
value; transitions starting in an absorbing state; transitions which start
at a time not covered by the time scale; and transitions which start or end in
a state which is not contained in the state space in the `dtms` object. This
can be changed through some of the arguments of `dtms_clean()`.

### Estimating transition probabilities

Getting transition probabilities ready requires three steps. First, estimating a
regression model for the transition probabilities. Second, predicting 
transition probabilities using this model. Third, putting the transition 
probabilities into a transition matrix. 

Estimating a regression model is done using `dtms_fit()`. Currently, this 
function builds on several other packages to allow for, among other things, 
semiparametric estimation and random effects. In the first example below, we
show a very basic call of this function:
```r
## Fit model 
fit <- dtms_fit(data=estdata)
```
This will estimate a model which only uses the starting state as a control. 
Covariates (including time) can be included in several ways. A convenient way for 
including covariates is to use the argument `controls`. For example, if in a 
data set there are two variables named `Z1` and `Z2`, and time is captured with 
a variable called `time`, then these variables could be included as follows:
```r
fit <- dtms_fit(data=somedata,
                controls=c("time","Z1","Z2"))
```
It is also possible to specify a formula, like is common practice for most 
regression functions. This way you have to specify the names of
the state variables:
```r
fit <- dtms_fit(data=somedata,
                formula=to~from+time+Z1+Z2)
```

What class of object is generated by `dtms_fit()` depends on the package which
is used for estimation. This is controlled by the argument `package`, with
`VGAM` as default and then using the function `vgam()`. This means that the 
resulting objects of the short examples above have class `vgam` and behave 
accordingly, in particular with methods for functions like `summary()` or 
`coef()`. In addition to `VGAM`, currently `mclogit` and `nnet` are supported.
If the package is set to `mclogit` the function `mblogit()` is used. If it is
`nnet` the function is `multinom()`. Arguments of these functions can be passed
via `dtms_fit()`. For instance, this example includes random effects by unit ID 
using the `mclogit` package and the argument `random` of `mblogit()`:
```r
fit <- dtms_fit(data=somedata,
                covariates=c("time","Z1","Z2"),
                package="mclogit",
                random=~1|id)
```

Once a regression model has been estimated, it can be used to predict
transition probabilities. If the model includes covariates, the user needs to
specify covariate values which are used in the prediction. If no covariates are 
included, then no values are needed. For each time-constant covariate one value needs 
to be specified, and for time-varying variables a value at each value of the 
timescale has to be provided minus the last value. For instance, if the timescale 
has values 0, 1, 2, and 3, and there is a time-varying covariate X, then values 
for X at 0, 1, and 2 need to be specified. Alternatively, predictor values 
for all values of the time scale can be specified. In this case, the last 
predictor value will be dropped. For a time-constant covariate Y only one values 
is necessary, which is then used at all values of the time scale.

To predict transition probabilities, the function `dtms_transitions()` is used.
It has three main arguments: `model`, `dtms`, and `controls`. The
first argument is used to specify the object which contains the regression 
model. The argument `dtms` takes the definition of the multistate model as
generated by `dtms()`. The argument `controls` is only 
needed if there are covariates in the model. It take as lists with named 
entries, where the names need to correspond to the names of the covariates in 
the model. For instance, in a model with a timescale
with values 0, 1, 2, and 3, and a time-constant covariate Y and a time-varying
covariate X, the call of `dtms_transitions()` could look as follows:
```r
probs <- dtms_transitions(model=fit,
                          dtms=example,
                          controls=list(time=0:3,
                                        Y=1,
                                        X=c(500,501,500,503))) 
```

The result of calling `dtms_transitions()` is a data frame with predicted
transition probabilities, where each row contains the transition probability 
for one specific transition, as indicated by the variables in the data. This
object will often be only an intermediate step. However, the package provides
several tools to look at the transition probabilities (see the examples below), 
and putting the probabilities in a data frame makes them easily accessible to
the user.

Transition probabilities in a data frame have to be converted to a transition
matrix before they can be used further. For this, we use the function 
`dtms_matrix()`. In most cases, this function will only require two arguments.
First, a data frame with transition probabilities as created with 
`dtms_transitions()` and passed to the argument `probs`; and, second, a `dtms` 
object as created with `dtms()`. For instance, in the first example below, 
this function is used as follows:
```r
Tp <- dtms_matrix(probs=probs,
                  dtms=simple)
```
This transition matrix can then be used to apply Markov chain methods. The 
matrix itself often will not be of major interest, and it is easier to look
at transition probabilities in the data frame generated with
`dtms_transitions()`.

### Markov chain methods

The dtms package provides several functions which implement Markov chain
methods and which can be applied to a transition matrix generated with
`dtms_matrix()`. Most of these functions require at least two arguments.
First, a transition matrix; and, second, a `dtms` object. For instance,
to calculate the lifetime spent in the different states, the function 
`dtms_expectancy()`. This and other functions are demonstrated in more detail 
in the two examples below.

## Example 1: Artificial data

This is a basic example using artificial data which is provided with the 
package. The state space consists of two transient states (A, B), and one 
absorbing state (X). The time scale goes from 0 to 20. Transition probabilities 
do change depending on time, as we will see below. 

The following code loads the package and the data set. The data set is called 
'simpledata'.
```{r example1-data}
## Load package 
library(dtms)

## Look at data
head(simpledata)

## States
simpledata$state |> unique()

## Number of units
simpledata$id |> unique() |> length()

## Number of observations
dim(simpledata)
```
The data set is in long format and contains three variables. 'id' is an unit 
identifier; 'time' contains the value of the time scale; and 'state' contains 
the state the unit occupied at a given time. In total, there are 993 units, 
each of them contributing to the total of 12,173 observations. 

To work with this data set, we first define a basic discrete-time multistate 
model. This is done with the function `dtms()` and requires us to specify the
names of the transient states, the names of the absorbing states, and the 
possible values of the time scale: 
```{r example1-modeldef}
## Define model: Absorbing and transient states, time scale
simple <- dtms(transient=c("A","B"),
               absorbing="X",
               timescale=0:19)
```
The resulting object of class `dtms` will be passed to other functions of the 
package.

In a second step, we transform the data from long format to transition format. 
This can be done using the function `dtms_format()`. In this 
example, we need to specify the name of the object containing the data, and
in addition a `dtms` object as created above. Moreover, we need to specify which
variables contain the unit identifier, which variable contains the values of 
the time scale, and which variable contains the information on the state:
```{r example1-transformat}
## Reshape to transition format
estdata <- dtms_format(data=simpledata,
                       dtms=simple,
                       idvar="id",
                       timevar="time",
                       statevar="state")

## Look at reshaped data
head(estdata)
```
While in long format each row contains information on the currently occupied
state, in transition format also the next state is shown in a variable. If there
is no observation at time t+1, the next state is NA. The names of the variables 
in the resulting data set are by default chosen such that they match defaults of 
other functions of the package. 

Depending on the original data, there can be missing values in transition format
data due to several reasons. The function `dtms_clean()` provides a convenient
way to remove such rows in the data, as well as other potentially problematic
or unwanted rows. It returns a cleaned data set and prints a brief overview
of the dropped rows to the console:
```{r example1-cleaning}
## Missing values?
estdata$to |> table(useNA="always")

## Clean
estdata <- dtms_clean(data=estdata,
                      dtms=simple)
```
In this example, 1,260 transitions were dropped because they end in a missing
value. No observations were dropped because the states are not covered by the
state space; no observations are dropped because they are out of the time range 
specified with the 'dtms' object; and no observations were dropped because they
start in an absorbing state.

A brief overview of the data is provided when using the function `summary()`:
```{r example1-summary}
## Summary of data
summary(estdata)
```
This shows for all possible transitions the absolute number each transition is
observed (e.g., there are 160 transitions from A to X); the proportion of 
each transition relative to all transitions (e.g., a bit more than 1% of all
observed transitions are from A to X); and raw transition probabilities (e.g.,
the probability of transitioning to X starting in A is around 4%).

Some more information on the data is provided by the function `dtms_censoring()`.
It can be used in different ways, but a basic version shows an overview of
the number of units with left censoring, the number of units with gaps in their
series of observations, and the number of units with right censoring:
```{r example1-censoring}
dtms_censoring(data=estdata,
               dtms=simple)
```

To estimate the transition probabilities of the multistate model, the function 
`dtms_fit()` is used. In this simple example, it is sufficient to specify the 
name of the object with the transition data and the time scale as a control
variable:
```{r example1-fit}
## Fit model 
fit <- dtms_fit(data=estdata,
                controls="time")
```
To predict transition probabilities and to arrange them in a matrix, the 
functions `dtms_transitions()` and `dtms_matrix()` are used. The function 
`dtms_transitions()` needs a 'dtms' object as well as a fitted model and values
for the control variable, while the function `dtms_matrix()` requires a 
`dtms` object and predicted probabilities: 
```{r example1-probs}
## Predict probabilities
probs    <- dtms_transitions(dtms=simple,
                             model = fit,
                             controls=list(time=simple$timescale))

## Get transition matrix 
Tp <- dtms_matrix(dtms=simple,
                  probs=probs)
```
In more complex examples, the previous functions would need more information. 
For instance, on which covariates to include in the estimation step, and which
covariate values to use in the prediction step. 

To get an overview of the transition probabilities, the function summary can be 
used:
```{r example1-probsctd}
## Summary of probabilities
summary(probs)
```
For all combinations of starting and receiving state, this shows the lowest 
transition probability and at what value of the time scale it occurs. It also
shows the same for the highest transition probability, and in addition it shows
the median and the mean of all transition probabilities between two states.

Another useful way to look at the transition probabilities is to plot them. To
make this easy, the package provides the function `dtms_simplify()` which can 
be applied to an object created with `dtms_transitions()` to make it easier to 
plot. For instance, using ggplot2, a simple plot could look like this:
```{r example1-probsplot}
## Simple plot
library(ggplot2)
probs |>  dtms_simplify() |> 
          ggplot(aes(x=time,y=P,color=to)) + 
          geom_line() + 
          facet_wrap(~from)
```
An even simpler way is available which builds on base-R and does not require 
ggplot2. However, this creates less nice figures and is mainly intended as a 
very quick way of checking results:
```{r example1-baseplot}
## Simple base plot
plot(probs,dtms=simple)
```

Before we generate more results, we calculate the starting distribution of
the states; i.e., the distribution of states at the first value of the time
scale. 
```{r example1-start}
## Get starting distribution 
S <- dtms_start(dtms=simple,
                data=estdata)
```
This step is not necessary, but its result can be passed to several of
the functions used for calculating Markov chain methods, providing additional 
information.

Most functions used to calculate Markov chain methods need a transition matrix 
and a `dtms` object, and potentially further arguments. The two examples below 
calculate the expected time spent in a state (`dtms_expectancy()`) and the 
lifetime risk of ever reaching a state (`dtms_risk()`). In the first case, the 
starting distribution of states is passed to the function; this is optional. In 
the second case, one or several states need to be specified for which the 
lifetime risk will be calculated:
```{r example1-results1}
## State expectancies 
dtms_expectancy(dtms=simple,
                matrix=Tp,
                start_distr=S)

## Lifetime risk 
dtms_risk(dtms=simple,
          matrix=Tp,
          risk="A")
```
The results of the call of `dtms_expectancy()` show the starting states in rows
and the states in which the time is spent as columns. For instance, around 5.05
time units are spent in state A when starting in state A at time 0. The last 
column shows the total time until absorption. The last row is shown because the
starting distribution was specified. It shows the average time spent in a state
irrespective of the starting state. That is, on average 4.93 time units are 
spent in state A, and 8.88 time units are spent in state B, for a total of 13.81 
time units. 

The result of the call of `dtms_risk()` above is the lifetime risk of ever
reaching state A depending on the starting state. Obviously, when starting in 
state A at time 0, this risk amounts to 1. When starting in state B, the risk is
also very high and around 97%. 

It is also possible to calculate state expectancies conditional on values of
the time scale. For this, a single transient state has to be specified for 
which we want to know how long units spent in it:
```{r example1-results1var}
dtms_expectancy(dtms=simple,
                risk="A",
                matrix=Tp)
```
In the example above, we look at the time spent in state A. The results by row
now indicate the remaining life expectancy in state A starting from the state
in the row at a given time. For instance, if a unit is in state A at time 5,
an additional 3.51 time units will be spent in state A (as seen in row named 
"A", column named "5"). 

The function calls below are all similar in that they provide full distributions
as a result. Specifically, `dtms_visits()` calculates the distribution of the 
time spent in a state; the mean over this distribution is equal to the state 
expectancy as provided by `dtms_expectancy()`, and one minus the proportion of 
0 time units spent in a state is equal to the lifetime risk provided by 
`dtms_risk()`. `dtms_first()` calculates the distribution of the waiting time
until a given state is reached for the first time, conditional on ever reaching
this state. `dtms_last()` calculates the distribution of the waiting time until
a state is left for the last time; i.e., there is no return back to this state.
```{r example1-results2}
## Distribution of visits
dtms_visits(dtms=simple,
            matrix=Tp,
            risk="A",
            start_distr=S)

## Distribution of waiting time to first visit
dtms_first(dtms=simple,
           matrix=Tp,
           risk="A",
           start_distr=S)

## Distribution of waiting time to last exit
dtms_last(dtms=simple,
          matrix=Tp,
          risk="A",
          start_distr=S,
          rescale=T,
          total=F)
```
The output from these functions tends to be difficult to read, and often 
results on the distribution are used to calculate other statistics. A 
set of such statistics can be generated using the function `summary()`:
```{r example1-results2-ctd}
## Distribution of visits
example <- dtms_visits(dtms=simple,
                       matrix=Tp,
                       risk="A",
                       start_distr=S)
summary(example)
```
In the example above this returns, respectively, the average lifetime spent in
state A; the variance of the lifetime spent in state A; the standard deviation 
of the lifetime spent in state A; the median of the lifetime spent in state A;
 and the probability of spending zero lifetime in state A. Depending on which
 distribution this function is applied to, some entries might not be defined. 
 For instance: 
```{r example1-results2-ctd2}
## Distribution of waiting time to last exit
example2 <- dtms_last(dtms=simple,
                      matrix=Tp,
                      risk="A",
                      start_distr=S,
                      rescale=T,
                      total=F)
summary(example2)
```
In this case, the distribution is conditional on ever experiencing the exit
from state A, such that the waiting time until exit always has to be above 0. 

With respect to inference, the package currently provides analytic standard
errors for transition probabilities, and simulated inference for all other 
statistics. Standard errors for transition probabilities are provided by 
default by the function `dtms_transitions()`, and it can also return confidence
intervals. Two methods for simulated inference are implemented: the (simple) 
bootstrap and the block bootstrap. Both methods are provided by the function
`dtms_boot()`. How to use `dtms_transitions()` and `dtms_boot()` for inference
is demonstrated in the second example below.

## Example 2: Working trajectories during late working life

Here we provide an example using simulated data based on the Health and 
Retirement Study (HRS). The simulations are are conducted using transition 
probabilities estimated from the HRS and published by Dudel & Myrskylä (2017) 
who studied working trajectories in late working life and old age. These
transition probabilities are used to simulate artificial but realistic 
trajectories. There are three transient states 
(working, non-working, retired) and one absorbing state (dead). 
The time scale represents age and ranges from 50 to 99, as the focus is on older
individuals. Note that the actual HRS data is collected every two years and 
while the simulated data is annual. The data set also contains each individual's 
gender, and the transition probabilities underlying the simulated trajectories 
differ between men and women.

The workflow is similar to the previous example. First, a 'dtms' model is 
defined using the function `dtms'. Second, the data is brought into 
transition format and cleaned. Third, transition probabilities are estimated
and put into a transition matrix. In this example, probabilities are estimated
and predicted using time-constant and time-varying covariates, and the 
probabilities are plotted together with confidence intervals. Finally, the 
transition matrix is used to calculate state expectancies and similar measures. 

```{r example2}
## Load packages
library(dtms)
library(ggplot2)

## Define model: Absorbing and transient states, time scale
hrs <- dtms(transient=c("Working","Non-working","Retired"),
            absorbing="Dead",
            timescale=50:99)

## Quick look at data
head(hrsdata)

## Reshape
estdata <- dtms_format(data=hrsdata,
                       dtms=hrs,
                       idvar="ID",
                       timevar="Age",
                       statevar="State")

## Drop dead-to-dead transitions etc
estdata <- dtms_clean(data=estdata,
                      dtms=hrs)

## Overview
summary(estdata)

## Basic censoring
dtms_censoring(data=estdata,
               dtms=hrs)

## More advanced censoring example
estdata <- dtms_censoring(data=estdata,
                          dtms=hrs,
                          add=T,
                          addtype="obs")

estdata |>
  subset(subset=to!="Dead",select=c(RIGHT,to)) |>
  table() |>
  prop.table(margin=1)

## Add age squared
estdata$time2 <- estdata$time^2
  
## Fit model
fit <- dtms_fit(data=estdata,
                controls=c("Gender","time","time2"))

## Transition probabilities by gender
  
# Men
probs_m <- dtms_transitions(dtms=hrs,
                            model = fit,
                            controls = list(Gender=0,
                                            time  =50:98,
                                            time2 =(50:98)^2),
                            CI=TRUE)
  
# Women
probs_w <- dtms_transitions(dtms=hrs,
                            model = fit,
                            controls = list(Gender=1,
                                            time  =50:98,
                                            time2 =(50:98)^2),
                            CI=TRUE)

# Overview
summary(probs_m)
summary(probs_w)

# Plotting, men as example
probs_m |>  dtms_simplify() |> 
            ggplot(aes(x=time,y=P,color=to)) + 
            geom_ribbon(aes(ymin = CIlow, ymax = CIup,fill=to),alpha=0.5) +
            geom_line() + 
            facet_wrap(~from)
 
## Transition matrices
Tm <- dtms_matrix(dtms=hrs,
                  probs=probs_m)
  
Tw <- dtms_matrix(dtms=hrs,
                  probs=probs_w)

## Starting distributions
Sm <- dtms_start(dtms=hrs,
                 data=estdata,
                 variables=list(Gender=0))
  
Sw <- dtms_start(dtms=hrs,
                 data=estdata,
                 variables=list(Gender=1))
  
## State expectancies
dtms_expectancy(dtms=hrs,
                matrix=Tm,
                start_distr=Sm)
    
dtms_expectancy(dtms=hrs,
                matrix=Tw,
                start_distr=Sw)

## Variant: ignoring retirement as a starting state (shown only for men)
limited <- c("Working","Non-working")

Smwr <- dtms_start(dtms=hrs,
                   data=estdata,
                   start_state=limited,
                   variables=list(Gender=0))

dtms_expectancy(dtms=hrs,
                matrix=Tm,
                start_state=limited,
                start_distr=Smwr)

## Lifetime risk of reaching retirement
dtms_risk(dtms=hrs,
          matrix=Tm,
          risk="Retired",
          start_distr=Sm)
  
dtms_risk(dtms=hrs,
          matrix=Tw,
          risk="Retired",
          start_distr=Sw)
  
## Distribution of visits
visitsm <- dtms_visits(dtms=hrs,
                       matrix=Tm,
                       risk="Retired",
                       start_distr=Sm)
  
visitsw <- dtms_visits(dtms=hrs,
                       matrix=Tw,
                       risk="Retired",
                       start_distr=Sw,
                       method="end")

summary(visitsm)
summary(visitsw)
  
## First visit
firstm <- dtms_first(dtms=hrs,
                     matrix=Tm,
                     risk="Retired",
                     start_distr=Sm)  
  
firstw <- dtms_first(dtms=hrs,
                     matrix=Tw,
                     risk="Retired",
                     start_distr=Sw)  

summary(firstm)
summary(firstw)

## Last exit
  
# Leaving work to any state
last1m <- dtms_last(dtms=hrs,
                    matrix=Tm,
                    risk="Working",
                    start_distr=Sm)  
  
last1w <- dtms_last(dtms=hrs,
                    matrix=Tw,
                    risk="Working",
                    start_distr=Sw) 

summary(last1m)
summary(last1w)
  
# Leaving work for retirement
last2m <- dtms_last(dtms=hrs,
                    matrix=Tm,
                    risk="Working",
                    risk_to="Retired",
                    start_distr=Sm)  
  
last2w <- dtms_last(dtms=hrs,
                    matrix=Tw,
                    risk="Working",
                    risk_to="Retired",
                    start_distr=Sw)  

summary(last2m)
summary(last2w)
```

```{r example2boot}
# Bootstrap example (not run)
bootfun <- function(data,dtms) {
 
   fit <- dtms_fit(data=data,
                   controls=c("Gender","time","time2"),
                   package="mclogit")
 
   probs_m <- dtms_transitions(dtms=dtms,
                               model = fit,
                               controls = list(Gender=0,
                                               time  =50:98,
                                               time2 =(50:98)^2))
 
   probs_w <- dtms_transitions(dtms=dtms,
                               model = fit,
                               controls = list(Gender=1,
                                               time  =50:98,
                                               time2 =(50:98)^2))
 
   Tm <- dtms_matrix(dtms=dtms,
                     probs=probs_m)
 
   Tw <- dtms_matrix(dtms=dtms,
                     probs=probs_w)
 
   Sm <- dtms_start(dtms=dtms,
                    data=data,
                    variables=list(Gender=0))
 
   Sw <- dtms_start(dtms=dtms,
                    data=data,
                    variables=list(Gender=1))
 
   res1 <- dtms_expectancy(dtms=dtms,
                   matrix=Tm,
                   start_distr=Sm)
 
   res2 <- dtms_expectancy(dtms=dtms,
                   matrix=Tw,
                   start_distr=Sw)
 
   rbind(res1,res2)
 
}
 
bootresults <- dtms_boot(data=estdata,
                         dtms=hrs,
                         fun=bootfun,
                         idvar="id",
                         rep=50,
                         method="block",
                         parallel=TRUE)

summary(bootresults)
```
To use bootstrap methods, the function `dtms_boot()` is called, and results can
be conveniently viewed using `summary()`. The function `dtms_boot()` needs
data in transition format (argument `data`) and a `dtms` object. The argument 
`method` is used to choose the bootstrap method; here, we use the block 
bootstrap. In case the block bootstrap is used the argument `idvar` needs to be
specified, which takes the name of the variable with the unit identifier. The 
argument `rep` sets the number of bootstrap replications, and the argument
`parallel` can be set to `TRUE` to enable parallel processing using the
packages [foreach](https://cran.r-project.org/web/packages/foreach) and 
[doParallel](https://cran.r-project.org/web/packages/doParallel).

Further required is the argument `fun`. This is a function which should have two 
arguments, one called `data` and one called `dtms`. These are used to pass the
corresponding arguments from `dtms_boot()`. Other than this the function can 
contain anything the user is interested in. In the example above, the function
is called `bootfun`. It estimates transition probabilities, puts them into a
transition matrix, and then calculates state expectancies. Each bootstrap 
replication of the data is passed to the function specified by `fun`, and 
the results are saved in a list with as many entries as there are replications.
The format of each entry of the list obviously depends on the definition of 
`fun`. 

The result of calling `summary(bootresults)` is by default a list with two 
entries which together provide the bootstrap percentiles, i.e., the bootstrap
confidence interval. The entries have the structure defined by `fun`. In this
example, the upper half of each entry are the state expectancies for men, while
the lower half are the state expectancies for women. For instance, the 95%
confidence interval for the average lifetime spent working ranges from
12.17 years to 12.67 years for men. The returned percentiles can be controlled
with the arguments of the summary method, `dtms_boot_summary()`.
